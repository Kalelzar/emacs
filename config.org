#+TITLE: Configuration
#+AUTHOR: Kalelzar

#+BEGIN_SRC emacs-lisp :tangle yes :exports none

;;; config.el -- Tangled source code of config.org -*- lexical-binding: t -*-
;;; Commentary:
;;; This is just an executable file created by pasting
;;; all emacs-lisp source code blocks from config.org into
;;; this file.

;;; Code:


#+END_SRC

* Personal Information
#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Borislav Atanasov"
      user-mail-address "natomanofglory@gmail.com")
#+END_SRC
* Misc

Set the customize file to a separate file.

#+BEGIN_SRC emacs-lisp :tangle yes

(setq custom-file (expand-file-name "custom.el" user-emacs-directory))

(load custom-file)
#+END_SRC



#+begin_src emacs-lisp :tangle yes

(defun get-repo-for-title ()
  (when buffer-file-name
    (s-wrap
   (s-chop-prefix "/"
                  (second
                   (s-split ":"
                            (repo-origin
                             (projectile-project-root
                              (f-dirname
                               (buffer-file-name)))))))
   "[" "]")))

;(setq frame-title-format
;                    '("" "emacs - %b " (:eval (get-repo-for-title))))



#+end_src

Allow installations from packages from github

#+begin_src emacs-lisp :tangle yes
(quelpa
 '(quelpa-use-package
   :fetcher git
   :url "https://github.com/quelpa/quelpa-use-package.git"))
(require 'quelpa-use-package)
#+end_src

#+RESULTS:
: quelpa-use-package



Set up [[https://melpa.org/#/lsp-mode][Language Server Protocol]].

This (or an equivalent, [[https://github.com/joaotavora/eglot][see eglot]]) is a
must for any serious development.

You /could/ theoretically go without it (considering it is a big performance hit)
but it *is* hard for me to justify it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package lsp-mode
  :commands lsp
  :hook ((c++-mode scala-mode) . #'lsp))
(use-package lsp-ui
  :commands lsp-ui-mode
  :after lsp)
(use-package company-lsp
  :commands company-lsp
  :after (lsp company))
#+END_SRC

#+RESULTS:

Kill. Whole. Lines. This should be the default.
I really don't understand why it isn't.

Not really necessary if you use ~crux-kill-whole-line~ like you are supposed to.

#+begin_src emacs-lisp :tangle yes
(setq kill-whole-line t)
#+end_src

#+RESULTS:
: t

I don't actually know what this does but the EmacsWiki told me to
put it in.

#+begin_src emacs-lisp :tangle yes
(autoload 'wl "wl" "Wanderlust" t)
#+end_src

#+RESULTS:
: wl

Watch my [[https://melpa.org/#/activity-watch-mode][emacs activity]] with
[[https://github.com/ActivityWatch/activitywatch/][ActivityWatch]]

#+begin_src emacs-lisp :tangle yes
(when (executable-find "aw-server")
  (use-package activity-watch-mode
    :defer 5
    :config (global-activity-watch-mode)
    :diminish activity-watch-mode))
#+end_src

#+RESULTS:

Set [[https://github.com/pwmt/zathura][zathura]] as the default pdf viewer

#+BEGIN_SRC bash
sudo pacman -S zathura zathura-pdf-mupdf
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'tex
  (require 'tex)
  (add-to-list 'TeX-view-program-selection
               '(output-pdf "Zathura")))
#+end_src

#+RESULTS:

More convenient ~*scratch*~ buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package scratch
  :commands scratch)
#+END_SRC

#+RESULTS:


~undo-tree~ is absolutely necessary.
You really shouldn't do anything without it (or an equivalent).

#+BEGIN_SRC emacs-lisp :tangle yes
(setq use-package-ensure-function 'use-package-ensure-elpa)
(use-package undo-tree
;  :quelpa (undo-tree :fetcher url
;                     :url "http://git.savannah.gnu.org/cgit/emacs/elpa.git/plain/packages/undo-tree/undo-tree.el")
  :diminish undo-tree-mode
  :config (global-undo-tree-mode))
(setq use-package-ensure-function 'quelpa)
#+END_SRC

#+RESULTS:
: t

Crux.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package crux)
#+END_SRC

#+RESULTS:

Auto rename pair tag in html/xml

#+begin_src emacs-lisp :tangle yes
(use-package auto-rename-tag
  :defer t)
#+end_src


Revert buffer automatically when underlying file is changed outside of Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-auto-revert-mode t)
#+END_SRC

#+RESULTS:
: t

Smarter tab.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq tab-always-indent 'complete)
#+END_SRC

#+RESULTS:
: complete

Switch between visible buffers / frames with shift + arrow keys

This requires =framemove.el= from [[https://github.com/emacsmirror/emacswiki.org/blob/master/framemove.el][EmacsWiki]].

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package windmove
  :bind (("S-<up>" . windmove-up)
         ("S-<left>" . windmove-left)
         ("S-<right>" . windmove-right)
         ("S-<down>" . windmove-down)))
;(add-to-list 'load-path "~/.config/emacs/elpa/framemove/")
;(require 'framemove)
(use-package framemove
   :quelpa (framemove
            :fetcher url
            :url "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/framemove.el")
   :after windmove
   :config
   (setq framemove-hook-into-windmove t)
   (windmove-default-keybindings))
#+END_SRC

#+RESULTS:
: t



Save buffers on buffer switch

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package super-save
  :diminish super-save-mode
  :config (super-save-mode +1))
;; add integration with ace-window
(add-to-list 'super-save-triggers 'ace-window)
#+END_SRC

#+RESULTS:
| ace-window | switch-to-buffer | other-window | windmove-up | windmove-down | windmove-left | windmove-right | next-buffer | previous-buffer |

Highlighting
#+BEGIN_SRC emacs-lisp :tangle yes
(global-hl-line-mode +1)
(diminish 'hl-line-mode)
#+END_SRC

#+RESULTS:

Add the ability to kill the current line without marking it

#+BEGIN_SRC emacs-lisp :tangle yes
;(use-package rect )
(require 'rect)
(crux-with-region-or-line kill-region)
(crux-with-region-or-line kill-ring-save)
#+END_SRC

#+RESULTS:
: kill-ring-save

Automatically clean up unused buffers.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package midnight
  :defer 30)
#+END_SRC

#+RESULTS:

Do not activate mark if there is no active region when
~exchange-point-and-mark~ (C-x C-x by default) is called.

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice exchange-point-and-mark (before deactivate-mark activate compile)
  "When called with no active region, do not activate mark."
  (interactive "P")
   (list (not (region-active-p))))
#+END_SRC

#+RESULTS:
: exchange-point-and-mark

Create macro for calling functions on region or buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro with-region-or-buffer (func)
  "When called with no active region, call FUNC on current buffer."
  `(defadvice ,func (before with-region-or-buffer activate compile)
     (interactive
      (if mark-active
          (list (region-beginning) (region-end))
        (list (point-min) (point-max))))))

(with-region-or-buffer indent-region)
#+END_SRC

#+RESULTS:
: indent-region

Show available keybindings after you start typing

#+BEGIN_SRC emacs-lisp :tangle yes

;; show available keybindings after you start typing
(use-package which-key
  :config
  (which-key-mode +1)
  (which-key-enable-god-mode-support nil)
  :diminish which-key-mode)
#+END_SRC

#+RESULTS:
: t

Following config mostly taken from [[https://github.com/bbatsov][bbatsov's]] [[https://github.com/bbatsov/prelude][Prelude]].

#+begin_src emacs-lisp :tangle yes

;; Copyright © 2011-2020 Bozhidar Batsov
;;
;; Author: Bozhidar Batsov <bozhidar@batsov.com>
;; URL: https://github.com/bbatsov/prelude
;; Version: 1.0.0
;; Keywords: convenience

(use-package smartparens
  :config ;; smart curly braces
  (sp-pair "{" nil :post-handlers
  '(((lambda (&rest _ignored)
  (crux-smart-open-line-above)) "RET"))))

(defun prelude-local-comment-auto-fill ()
  (set (make-local-variable 'comment-auto-fill-only-comments) t))

;; show the name of the current function definition in the modeline
(use-package which-func
  :config (which-function-mode 1))

;; font-lock annotations like TODO in source code
(use-package hl-todo
  :config (global-hl-todo-mode 1))

;; in Emacs 24 programming major modes generally derive from a common
;; mode named prog-mode; for others, we'll arrange for our mode
;; defaults function to run prelude-prog-mode-hook directly.  To
;; augment and/or counteract these defaults your own function
;; to prelude-prog-mode-hook, using:
;;
;;     (add-hook 'prelude-prog-mode-hook 'my-prog-mode-defaults t)
;;
;; (the final optional t sets the *append* argument)

(defun prelude-prog-mode-defaults ()
  "Default coding hook, useful with any programming language."
  (flyspell-prog-mode)
  (smartparens-mode +1)
  (prelude-local-comment-auto-fill))

(setq prelude-prog-mode-hook 'prelude-prog-mode-defaults)

(add-hook 'prog-mode-hook (lambda ()
                            (run-hooks 'prelude-prog-mode-hook)))

;; enable on-the-fly syntax checking
#+end_src

#+RESULTS:
| lambda | nil | (run-hooks 'prelude-prog-mode-hook) |
** Packages

I have recently (READ: for a few months) been skimping on installing new
packages the proper way, since it is way easier to just run
=(package-list-packages)= that to write stuff in the config.


I wanted to rectify that so I wrote a couple of helper functions.

#+begin_src emacs-lisp :tangle yes
(defun get-packages-installed-by-config ()
  "Return a list of all packages installed with `use-package' by the config."
  (--map
   (s-replace ")" "" (second (s-split " " it)))
   (--filter
    (s-prefix? "(use-package" it)
    (--map
     (s-trim it)
     (--filter
      (s-contains? "use-package" it)
      (-flatten
       (--map
        (s-lines (f-read it))
        (f-glob "*.el" user-emacs-directory))))))))

(defun get-selected-packages-not-in-config ()
  "Return a list of all packages that are in `package-selected-packages' but
aren't explicitly installed by config."
  (-map
   #'symbol-name
   (-difference
    (package--find-non-dependencies)
    (-map
     #'intern
     (get-packages-installed-by-config)))))

(defun show-populated-buffer (populate-function buffer-name)
  "Open a buffer called BUFFER_NAME and fill it using POPULATE_FUNCTION"
  (with-current-buffer (get-buffer-create buffer-name)
    (insert (s-join "\n" (funcall populate-function))))
  (view-buffer buffer-name #'kill-buffer))

(defun show-packages-installed-by-config ()
  "Open a buffer containing all packages explicitly installed by config."
  (interactive)
  (show-populated-buffer #'get-packages-installed-by-config
                         "*Installed Packages*"))

(defun show-selected-packages-not-in-config ()
  "Open a buffer containing all (not-dependency) packages not explicitly installed by config."
  (interactive)
  (show-populated-buffer #'get-selected-packages-not-in-config
                         "*Missing Packages*"))
#+end_src

* Sane Defaults

Some are sourced from [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config]].

For some reason these functions are disabled.

#+BEGIN_SRC emacs-lisp :tangle yes
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

#+RESULTS:

Yes is two letters too long for me.

#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

#+RESULTS:
: yes-or-no-p

Clean up back-ups / autosaves.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
(setq auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "auto-save-list/") t)))
#+END_SRC

#+RESULTS:
| .* | /home/kalelzar/.config/emacs/auto-save-list/ | t |

UTF-8.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

#+RESULTS:

Don't indent with TABS please.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
#+END_SRC

#+RESULTS:

Indicate empty lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default indicate-empty-lines t)
#+END_SRC

#+RESULTS:
: t

Don't count two spaces after a period as the end of a sentence.
Just one space is needed.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+END_SRC

#+RESULTS:

Delete the region when typing.

#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode t)
#+END_SRC

#+RESULTS:
: t

Logical buffer names.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

#+RESULTS:
: forward

Load aliases from .bash_profile

#+BEGIN_SRC emacs-lisp :tangle yes
(setq shell-command-switch "-ic")
#+END_SRC

#+RESULTS:
: -ic

Silence!

#+BEGIN_SRC emacs-lisp :tangle yes
(setq visible-bell t)
(setq ring-bell-function 'ignore)
#+END_SRC

#+RESULTS:
: ignore

* Modes
** Flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :diminish flycheck-mode
  :commands (global-flycheck-mode flycheck-mode)
  :config
  (setq flycheck-html-tidy-executable "tidy5"))
#+END_SRC

#+RESULTS:
: t

Enable flyspell

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell
  :when (executable-find "aspell")
  :defer 5
  :diminish flyspell-mode
  :bind ("C->" . flyspell-correct-word-before-point)
  :config (setq ispell-program-name "aspell"
                ispell-extra-args (listp "--sug-mode=ultra"))
  (flyspell-mode +1))

#+END_SRC

#+RESULTS:
: flyspell-correct-word-before-point
** Org

Fetch the latest version of org mode as per [[http://orgmode.org/elpa.html][this instructions]].
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :ensure org-plus-contrib)
#+END_SRC

#+RESULTS:

*** Babel

Don't ask for confirmation when evaluating code blocks.
It's annoying.

#+begin_src emacs-lisp :tangle yes
  (setq org-confirm-babel-evaluate nil)
#+end_src

#+RESULTS:

Enable some languages for evaluation in Org code blocks.

#+begin_src emacs-lisp :tangle yes
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (C . t)
     (shell . t)
     (lisp . t)))
#+end_src

#+RESULTS:

*** Export

I mainly export to \LaTeX but that comes installed by default.

#+RESULTS:

#+begin_src emacs-lisp :tangle yes
  (setq org-export-backends
     (quote
      (html latex)))
#+end_src

#+RESULTS:
| ascii | beamer | html | latex | epub |

Enable linting of source code blocks when exported to \LaTeX
This requires [[https://github.com/gpoore/minted][minted]].

On Archlinux:

#+BEGIN_SRC bash
sudo pacman -S minted
#+END_SRC

#+RESULTS:

You also might need to install some of the (La)TeX libraries included by your distribution.

#+begin_src emacs-lisp :tangle yes
  (use-package ox-latex
    :after org
    :config
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (add-to-list 'org-latex-packages-alist '("" "color"))
    (add-to-list 'org-latex-packages-alist '("" "xcolor"))
    (add-to-list 'org-latex-packages-alist '("" "mathtools"))
    (add-to-list 'org-latex-packages-alist '("" "amsmath"))
    (setq org-latex-listings 'minted)

    (setq org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
#+end_src

#+RESULTS:
: t

*** Templates

Enable Org Tempo mode for template expansion

#+begin_src emacs-lisp :tangle yes
  (use-package org-tempo)
#+end_src

#+RESULTS:

Source blocks
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("ll" . "src lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("sh" . "src sh"))
(add-to-list 'org-structure-template-alist '("bh" . "src bash"))
(add-to-list 'org-structure-template-alist '("sc" . "src scala"))
#+END_SRC

#+RESULTS:
: ((sc . src scala) (bh . src bash) (sh . src sh) (py . src python) (ll . src lisp) (el . src emacs-lisp) (a . export ascii) (c . center) (C . comment) (e . example) (E . export) (h . export html) (l . export latex) (q . quote) (s . src) (v . verse))

*** Misc
Set up emphasis symbols

#+begin_src emacs-lisp :tangle yes
  (setq org-emphasis-alist
        (quote
         (("*" bold)
          ("/" italic)
          ("_" underline)
          ("=" org-verbatim verbatim)
          ("~" org-code verbatim)
          ("+"
           (:strike-through t)))))
#+end_src

#+RESULTS:
| * | bold                |          |
| _ | underline           |          |
| = | org-verbatim        | verbatim |
| ~ | org-code            | verbatim |
| + | (:strike-through t) |          |

Set up better link previews using [[https://github.com/stardiviner/org-link-beautify][org-link-beautify]].

It is not available in MELPA.

So we have to install it manually.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-link-beautify
  :quelpa (org-link-beautify
           :fetcher github
           :repo "stardiviner/org-link-beautify")
  :disabled t)
#+END_SRC

#+RESULTS:

Or so I would like. But it's way too laggy and the icons show up wrong for me.

Enable some good minor modes for working with org-mode
when /in/ org-mode.

#+begin_src emacs-lisp :tangle yes
    (use-package org-superstar)
    ;(use-package org-sticky-header )
    (setq use-package-ensure-function 'use-package-ensure-elpa)
    (use-package tex-site :ensure auctex)
    (setq use-package-ensure-function 'quelpa)
    (use-package cdlatex
      :after tex-site)

    (defun org-mode-enable-minor-modes-hook ()
      "Enable some good minor-modes for fancier 'org-mode' experience."
      (org-superstar-mode 1)
      (diminish 'org-superstar-mode)
      ;;(org-sticky-header-mode 1)
      (org-indent-mode 1)
      (diminish 'org-indent-mode)
      ;;(org-cdlatex-mode 1)
      (diminish 'org-cdlatex-mode)
      (yas-minor-mode 1)
      (diminish 'yas-minor-mode)
      (fira-code-mode 1)
      (diminish 'fira-code-mode)
      ;;(org-link-beautify-mode 1)
      )

(add-hook 'org-mode-hook 'org-mode-enable-minor-modes-hook)
#+end_src

#+RESULTS:
| org-mode-enable-minor-modes-hook | org-tempo-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

Let TAB behave as expected when inside code block.

#+begin_src emacs-lisp :tangle yes
(setq org-src-tab-acts-natively t)
#+end_src

#+RESULTS:
: t

Set the default notes file.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-default-notes-file "~/Documents/notes.org")
#+END_SRC

#+RESULTS:
: ~/Documents/notes.org

Enable speed commands.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-use-speed-commands t)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-tags-column 45)
#+END_SRC

#+RESULTS:
: 45

Enable windmove/framemove in org-mode.

#+begin_src emacs-lisp :tangle yes
;(setq org-support-shift-select nil)
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

#+RESULTS:
| windmove-right |

Make latex previews in org-mode twice as big.

#+begin_src emacs-lisp :tangle yes
(setq org-format-latex-options (append '(:scale 2.0) org-format-latex-options ))
#+end_src

#+RESULTS:
| :scale | 2.0 | :foreground | default | :background | default | :scale | 2.0 | :html-foreground | Black | :html-background | Transparent | :html-scale | 1.0 | :matchers | (begin $1 $ $$ \( \[) |

Add custom TODO keywords

#+begin_src emacs-lisp :tangle yes

(setq org-todo-keywords
  '((sequence "INACTIVE(i!)" "SCHEDULED(s!)" "NEXT(n!)" "ACTIVE(a!)" "|" "DONE(d!)" "CANCELLED(c!)")
    (sequence "SUSPENDED(p!)")
    (sequence "EXPORT(e)" "|" "EXPORTED")))
#+end_src

#+RESULTS:
| sequence | INACTIVE(i!)  | SCHEDULED(s!) | NEXT(n!) | ACTIVE(a!) |   |   | DONE(d!) | CANCELLED(c!) |
| sequence | SUSPENDED(p!) |               |          |            |   |   |          |               |
| sequence | EXPORT(e)     |               |          | EXPORTED   |   |   |          |               |

Set custom faces for TODO keywords.

#+begin_src emacs-lisp :tangle yes
(setq org-todo-keyword-faces
  '(("INACTIVE" . "#004488" )
    ("SCHEDULED" . "#aa6600")
    ("NEXT" . "#006622")
    ("ACTIVE" . (:background "#004400" :foreground "white" :weight bold ))
    ("SUSPENDED" . (:background "#440000" :foreground "white" :weight bold ))
    ("DONE" . (:foreground "#204420" :weight bold))
    ("CANCELLED" . "#616161" )
    ("EXPORT" . (:background "#443322" :foreground "#ffaa00" ))
    ("EXPORTED" . "#414141" )))
#+end_src

#+RESULTS:
: ((INACTIVE . #004488) (SCHEDULED . #aa6600) (NEXT . #006622) (ACTIVE :background #004400 :foreground white :weight bold) (SUSPENDED :background #440000 :foreground white :weight bold) (DONE :foreground #204420 :weight bold) (CANCELLED . #616161) (EXPORT :background #443322 :foreground #ffaa00) (EXPORTED . #414141))

Obviously you can't really work on two tasks at the same time.
So let's enforce a single ACTIVE task at all times.

#+begin_src emacs-lisp :tangle yes
(when (file-exists-p "~/Code/Projects/kaltask")
  (use-package kaltask
    :quelpa (kaltask :fetcher file
                     :path "~/Code/Projects/kaltask")))
#+end_src

#+RESULTS:


Enforce todo dependencies.

#+begin_src emacs-lisp :tangle yes
(setq org-enforce-todo-dependencies t)
#+end_src

#+RESULTS:
: t

Enable org-drill.

#+begin_src emacs-lisp :tangle yes
(use-package org-drill)
(setq org-drill-hide-item-headings-p t)
#+end_src

Show live-preview of latex fragements.

#+begin_src emacs-lisp :tangle yes
(use-package org-elp)
#+end_src

Add a company backend for math.

#+begin_src emacs-lisp :tangle yes
(use-package company-math
  :after company)
#+end_src

*** Agenda

Register the agenda files.

#+begin_src emacs-lisp :tangle yes
(defvar org-agenda-files-root
  "~/Documents/" "Store the root of all org-agenda files")

;(setq org-agenda-files nil)

(defvar org-agenda-files-assoc
  '(( "agenda" . ( "* INACTIVE %?\nAdded on %U\n%i" org-ask-location))
    ( "notes" . "* INACTIVE %?\nAdded on %U\n%i")
    ( "tickler" . "* INACTIVE %?\nDEADLINE: %^{Deadline}T\nAdded on %U\n%a\n%i"))
"A agenda name associated with the format for org-capture entries."
)

(defun expand-to-agenda-file (file)
  "Expand FILE to a path to an .org file located at `org-agenda-files-root'."
  (concat (concat org-agenda-files-root file) ".org"))


(defun org-register-agenda-file (file)
  "Register an agenda FILE."
  (add-to-list 'org-agenda-files
               (expand-to-agenda-file file)))


(seq-do 'org-register-agenda-file
              (mapcar (lambda (elem)  (car elem))
                      org-agenda-files-assoc))

(defvar org-agenda-shortcuts-prefix-key "H-z"
  "Prefix key for accessing org-agenda-shortcuts")

(bind-key
 (concat org-agenda-shortcuts-prefix-key
         (concat " " org-agenda-shortcuts-prefix-key))
 'previous-buffer)

(defun generate-shortcuts-to-agenda-file (agenda-file)
  (let* ((key (char-to-string (string-to-char agenda-file)))
         (key-chords (concat org-agenda-shortcuts-prefix-key (concat " " key))))
    (bind-key key-chords `(lambda () (interactive) (find-file (expand-to-agenda-file ,agenda-file))))
    (which-key-add-key-based-replacements key-chords agenda-file)
))

(seq-do 'generate-shortcuts-to-agenda-file
              (mapcar (lambda (elem)  (car elem))
                      org-agenda-files-assoc))

#+end_src

#+RESULTS:
| agenda | notes | tickler |

Create capture templates for quick writes to different
agenda files.

#+begin_src emacs-lisp :tangle yes
(defun org-ask-location ()
  (setq org-refile-use-outline-path nil)
  (let* ((org-refile-targets '((nil :maxlevel . 1)))
         (hd (condition-case nil
                 (car (org-refile-get-location "Headline" nil t))
               (error (car org-refile-history)))))
    (goto-char (point-min))
    (outline-next-heading)
    (if (re-search-forward
         (format org-complex-heading-regexp-format (regexp-quote hd))
         nil t)
        (goto-char (point-at-bol))
      (goto-char (point-max))
      (or (bolp) (insert "\n"))
      (insert "* " hd "\n")))
  (setq org-refile-use-outline-path 'file)
  (end-of-line))

(setq org-capture-templates nil)

(defun build-capture-template-definition
    (capture-key capture-description agenda-file template)
  "Generate a capture template.
 The capture template can be accessed with CAPTURE-KEY.
 It is described by CAPTURE-DESCRIPTION.
 It points to AGENDA-FILE.
 And it uses TEMPLATE to generate the entry.
 TEMPLATE is either a string with which to format the entry,
 or a cons cell of a string with which to format the entry and a function which
 tells where exactly in the file to add the new entry."
  (append (list capture-key capture-description)
          '(entry)
          (if (char-or-string-p template)
          (list (append '(file)
                        (list agenda-file)))
          (list (append '(file+function)
                        (list agenda-file) (cdr template))))
          (if (char-or-string-p template)
              (list template)
              (list (car template)))))

(defun org-generate-agenda-capture-template-definition (agenda-file)
  (let* ((agenda-name (file-name-base agenda-file))
         (capture-key (char-to-string (string-to-char agenda-name)))
         (capture-description (concat (concat "Add entry to " agenda-name) "."))
         (template (cdr (assoc agenda-name org-agenda-files-assoc))))
    (build-capture-template-definition
     capture-key capture-description agenda-file template)))

(defun register-agenda-capture-template-from-agenda-file (agenda-file)
  (add-to-list 'org-capture-templates
      (org-generate-agenda-capture-template-definition agenda-file)))

(defun register-agenda-capture-templates-from-agenda-files ()
  (seq-do 'register-agenda-capture-template-from-agenda-file
        org-agenda-files))

(register-agenda-capture-templates-from-agenda-files)

(add-to-list 'org-capture-templates
  (build-capture-template-definition "e" "Export entry"
    (expand-to-agenda-file "notes")
    "* EXPORT %?\nAdded on %U\n%i" ))

#+end_src

#+RESULTS:
| e | Export entry | entry | (file ~/Documents/notes.org) | * EXPORT %? |

Add state changes to a drawer.

#+begin_src emacs-lisp :tangle yes
(setq org-log-into-drawer t)
#+end_src

#+RESULTS:
: t

Set up archivation.

#+begin_src emacs-lisp :tangle yes
(setq org-archive-location (concat (expand-to-agenda-file "archive") "::"))

;;Requires Org >= 9.4
;(setq org-archive-subtree-save-file-p t)
;;Org < 9.4

(defun save-notes-archive-file ()
  (interactive)
  (save-some-buffers
   'no-confirm (lambda ()
                 (equal buffer-file-name
                        (expand-file-name (expand-to-agenda-file "archive"))))))

(advice-add 'org-archive-subtree :after #'save-notes-archive-file)

#+end_src

#+RESULTS:

Set up refiling

#+begin_src emacs-lisp :tangle yes
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-targets '((org-agenda-files . (:level . 0))))

  (defvar org-files-refile-internally
  (list (expand-file-name (expand-to-agenda-file "agenda")))
  "List of files which should be offered a list of internal headlines
  instead of other files")

  (defun dynamic-org-refile-get-targets (func &rest args)
    "Extend `org-refile-get-targets' in various contexts.
     If the file visited in current buffer is inside
     `org-files-refile-internally' then show a list of top-level headings to
     refile to instead of the default `org-refile-targets'.
     If the file visited in current buffer is a member of
     `org-agenda-files', remove it from the list so it doesn't clutter the
     target list. All changes to variables are restored at the end of the
     function."
     (setq org-refile-history nil)
     (let ((current-file (buffer-file-name (current-buffer))))
       (if (member current-file org-files-refile-internally)
           (let ((org-refile-use-outline-path nil)
                 (org-refile-targets nil))
             (apply func args))
         (let ((org-agenda-files (remove-if
             (lambda (file)
               (equal current-file (expand-file-name file)))
             org-agenda-files)))
           (apply func args)))))

  (advice-add 'org-refile-get-targets :around #'dynamic-org-refile-get-targets)
#+end_src

#+RESULTS:

Set up alerts for agenda items.

#+begin_src emacs-lisp :tangle yes
(use-package org-wild-notifier
  :after org
  :config
  (setq alert-default-style 'libnotify)
  (setq org-wild-notifier-keyword-whitelist nil)
  (org-wild-notifier-mode 1))
#+end_src

#+RESULTS:
: t

*** Roam

#+begin_src emacs-lisp :tangle yes
(use-package org-roam
  :config
(unless (f-dir? "~/Documents/Knowledge/src/org")
  (make-directory "~/Documents/Knowledge/src/org"))
(setq org-roam-directory "~/Documents/Knowledge/src/org")
(setq org-roam-db-location "~/Documents/Knowledge/src/org/org-roam.db")
(setq org-roam-link-auto-replace t)
(add-hook 'after-init-hook 'org-roam-mode)

(setq org-roam-title-sources '((title headline) alias))
(setq org-roam-tag-sources '(prop vanilla all-directories))
(setq org-roam-index-file "index.org")

(setq org-roam-completion-everywhere t)

(setq org-id-track-globally t)

(org-id-update-id-locations (f-glob "*.org" org-roam-directory)))

(use-package lister
  :after org-roam
  :quelpa (lister :fetcher git
  		  :url "https://github.com/publicimageltd/lister"))

(use-package delve
  :after lister
  :quelpa (delve :fetcher git
		 :url "https://github.com/publicimageltd/delve")
  :config
  (use-package delve-minor-mode
    :config
    (add-hook 'org-mode-hook #'delve-minor-mode-maybe-activate)
    (setq delve-use-icons-in-completions t))
  :bind
  (("<f12>" . delve-open-or-select)))



(defun find-roam-notes-with-tag (tag)
  (let ((search (delve-db-query-pages-with-tag tag)))
    (when search
      (delve search (format "of tag %s" tag)))))

(defun org-roam-open-file-by-title (title)
  (org-roam--find-file
   (first
    (-flatten
     (org-roam-db-query [:select [file]
                                 :from titles
                                 :where (= title $s1)]
                        title)))))

(defun org-roam-protocol-find-tag (info)
  (when-let ((tag (plist-get info :tag)))
    (raise-frame)
    (find-roam-notes-with-tag tag))
  nil)

(defun org-roam-protocol-find-by-title (info)
  (when-let ((title (plist-get info :title)))
        (raise-frame)
        (org-roam-open-file-by-title title)))

(require 'org-protocol)

(push '("org-roam-tag" :protocol "roam-tag"
:function org-roam-protocol-find-tag)
      org-protocol-protocol-alist)

(push '("org-roam-file-by-title" :protocol "roam-by-title"
        :function org-roam-protocol-find-by-title)
      org-protocol-protocol-alist)

(setq org-roam-graph-exclude-matcher "recentchanges.org")
(setq org-roam-graph-node-extra-config '(("shape"      . "rectangle")
          ("style"      . "rounded,filled")
          ("fillcolor"  . "#273434")
          ("fontname" . "sans")
          ("fontsize" . "12px")
          ("labelfontname" . "sans")
          ("color"      . "#b75867")
          ("fontcolor"  . "#c4c7c7")))

(setq org-roam-graph-edge-extra-config
      '(("dir" . "back")
        ("color" . "#b75867")))


(setq org-roam-graph-extra-config
      '(("rankdir" . "BT")
         ("bgcolor" . "\"#132020\"")))

(use-package org-roam-server
  :commands org-roam-server-mode
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 7000
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files t
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows "from"
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))

(defvar roam-subjects '("Numeric Methods"
                        "Linear Algebra"
                        "Logic Programming"
                        "Computer Architectures"
                        "Design and Analysis of Algorithms"
                        "Discrete Structures"
                        "Geometry of Movement")
"Subjects used as auto-complete for `make-roam-template'")

(defun make-roam-template (name)
  "Create roam template with NAME."
  (let ((key (char-to-string (downcase (string-to-char name))))
        (completion (string-join roam-subjects "|")))
    `(,key ,name entry #'org-roam--capture-get-point
           "* ${title}\n %?"
           :file-name "${slug}"
           :head ,(concat "#+title: ${title}\n#+roam_alias: \"${title}\"\n#+roam_tags: \"%^{prompt|General|"
                          completion
                          "}\" \""
                          name
                          "\"\n")
           :unnarrowed t)))

(defvar roam-template-types '("Theorem" "Definition" "Lecture"))

(setq org-roam-capture-templates nil)

(dolist (template (mapcar #'make-roam-template roam-template-types))
  (add-to-list 'org-roam-capture-templates template))

#+end_src
** C/C++

Set LSP for C/C++ using [[https://github.com/MaskRay/ccls][ccls]].

#+BEGIN_SRC bash
sudo pacman -S ccls
#+END_SRC

We also need the [[https://melpa.org/#/ccls][emacs package]].

#+begin_src emacs-lisp :tangle yes
(use-package ccls
  :hook ((c-mode c++-mode objc-mode cuda-mode) .
         (lambda ()
           (ccls-code-lens-mode))))

(setq ccls-executable "/usr/bin/ccls")
#+end_src

#+RESULTS:
: /usr/bin/ccls

Enable some refactoring with [[https://melpa.org/#/srefactor][srefactor]].

#+begin_src emacs-lisp :tangle yes
  (use-package srefactor
    :after ccls)
#+end_src

#+RESULTS:

This package displays function signatures in the mode line.
#+begin_src emacs-lisp :tangle yes
 (use-package c-eldoc
  :commands c-turn-on-eldoc-mode
  :init (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode))
#+end_src

#+RESULTS:
| c-turn-on-eldoc-mode | (lambda nil (ccls-code-lens-mode)) | macrostep-c-mode-hook |

** Novel mode

#+begin_src emacs-lisp :tangle yes
(use-package novel-mode
 :quelpa (novel-mode
          :fetcher github
          :repo "TLINDEN/novel-mode"))
#+end_src

#+RESULTS:

** Edit Server


Enable editing of browser text fields in Emacs.
Just because it's possible.

#+begin_src emacs-lisp :tangle yes
  (use-package edit-server
    :commands edit-server-start
    :init (if after-init-time
              (edit-server-start)
            (add-hook 'after-init-hook
                      #'(lambda() (edit-server-start))))
    :config (setq edit-server-new-frame-alist
                  '((name . "Edit with Emacs")
                    (minibuffer . t)
                    (menu-bar-lines . t)
                    (window-system . x))))

#+end_src

#+RESULTS:
: t

** Emms
#+begin_src emacs-lisp :tangle yes

(use-package emms
  :config
  (emms-all)
  (emms-default-players))

#+end_src
** Reading

Make reading stuff in Emacs easier.

#+begin_src emacs-lisp :tangle yes
  (defun reading-mode ()
    "Enable a major mode and some minor modes useful for reading."
    (interactive)
    (fundamental-mode)
    (text-scale-set 1)
    (visual-line-mode 1)
    (set-frame-font "Roboto")
    (set-fill-column 65)
    (set-justification-full (point-min) (point-max))
    (set-left-margin (point-min) (point-max) 7)
    (split-window-horizontally)
    (follow-mode 1)
    (read-only-mode 1))
#+end_src

#+RESULTS:
: reading-mode

** IDO
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ido
  :disabled t
  :init
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode t)
  (use-package ido-vertical-mode
    :defer t
    :init (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only)))
#+END_SRC

#+RESULTS:

** Whitespace
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package whitespace)

(setq whitespace-line-column 80) ;; limit line length
(setq whitespace-style '(face tabs empty trailing lines-tail))
(global-whitespace-mode)
(diminish 'global-whitespace-mode)

(defun cleanup-on-save ()
  "Call `whitespace-cleanup' on save"
  (whitespace-cleanup))

(add-hook 'before-save-hook 'cleanup-on-save)
#+END_SRC

#+RESULTS:
| cleanup-on-save |

** Helm
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm
  :diminish helm-mode
  :init
  (require 'helm-config)
  :config
  ;;(helm-mode 1)
  (setq helm-locate-command "mdfind -interpret -name %s %s"
        helm-ff-newfile-prompt-p nil
        helm-M-x-fuzzy-match t)
  :bind ("C-c h i" . helm-imenu))
(use-package helm-projectile
  :after (helm projectile)
  :commands helm-projectile
  :bind ("C-c p h" . helm-projectile))
(use-package helm-ag
  :after helm)
(use-package helm-swoop
  :after helm
  :bind ("C-S" . helm-swoop)
  :config
  (setq helm-swoop-fontify-buffer-size-limit 'always
                helm-swoop-use-line-number-face t
                helm-swoop-speed-or-color t))
#+END_SRC

** Ivy
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :diminish (ivy-mode . "")
  :bind
  (:map ivy-mode-map
        ("C-'" . ivy-avy))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; Show candidate index and total count
  (setq ivy-count-format "(%d/%d) ")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
        '((t   . ivy--regex-ignore-order))))
(use-package avy)
(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x C-r" . counsel-recentf)
         ("C-c h i" . counsel-imenu)
         ("C-h v" . counsel-describe-variable)
         ("C-h f" . counsel-describe-function)
         ("C-x C-f" . counsel-find-file)
         ("C-x b" . counsel-switch-buffer)
         ("M-y" . counsel-yank-pop)
         ("C-x f" . counsel-fzf)))
(use-package counsel-projectile
  :after (counsel projectile)
  :config
;  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (counsel-projectile-mode)
  (setq counsel-projectile-switch-project-action 'dired))
(use-package swiper
  :after counsel
  :bind (("C-s" . swiper)))
(use-package ivy-yasnippet
  :after (ivy yasnippet))
#+END_SRC

#+RESULTS:
: swiper

** HTMLize
#+begin_src emacs-lisp :tangle yes
(use-package htmlize)
#+end_src

** Typescript
#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :commands typescript-mode)
(use-package tss
  :after typescript-mode)
#+end_src

** JavaScript
#+begin_src emacs-lisp :tangle yes
(setq js-indent-level 2)
#+end_src
** CSS
#+begin_src emacs-lisp :tangle yes
(setq css-indent-offset 2)
#+end_src
** SCSS
#+begin_src emacs-lisp :tangle yes
(use-package scss-mode)
(use-package postcss-sorting
  :after css-mode
  :quelpa (postcss-sorting
           :fetcher git
           :url "https://github.com/P233/postcss-sorting.el.git")
:config
(add-hook 'css-mode-hook
          (lambda ()
            (add-hook 'before-save-hook 'postcss-sorting-buffer t t))))
#+end_src

** Cakecrumbs

Show parent's chain on header for web-releated files

#+begin_src emacs-lisp :tangle yes
(use-package cakecrumbs
  :config
  (setq cakecrumbs-html-major-modes   '(mhtml-mode html-mode web-mode nxml-mode sgml-mode))
  (setq cakecrumbs-jade-major-modes   '(yajade-mode jade-mode pug-mode))
  (setq cakecrumbs-scss-major-modes   '(scss-mode less-css-mode css-mode))
  (setq cakecrumbs-stylus-major-modes '(stylus-mode sass-mode))
  (cakecrumbs-auto-setup)
  (setq cakecrumbs-separator ">"))
#+end_src

** CalibreDB

Use emacs as a calibre client.

#+begin_src emacs-lisp :tangle yes
(use-package calibredb
  :defer t
  :commands (calibredb calibredb-find-counsel)
  :config
  (setq calibredb-root-dir "~/Documents/Library")
  (setq calibredb-db-dir (f-join calibredb-root-dir "metadata.db"))
  (setq calibredb-ref-default-bibliography (f-join calibredb-root-dir "catalog.bib"))
  (setq calibredb-library-alist '(("~/Documents/Library")))
  (setq calibredb-format-all-the-icons t)
  (setq calibredb-virtual-library-alist
        '(("Default" . "^\\(epub\\|mobi\\|pdf\\|docx\\)")))
  (setq calibredb-virtual-library-default-name "Default")
)

#+end_src

** Vue
#+begin_src emacs-lisp :tangle yes
(use-package vue-mode
  :commands vue-mode)
#+end_src
** Magit
A great interface for git projects.
It’s much more pleasant to use than the git interface
on the command line. Use an easy keybinding to access magit.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :demand
  :bind (("C-c g" . magit-status)
         ("C-c G" . magit-dispatch)
         ("C-c m l" . magit-log-buffer-file)
         ("C-c m b" . magit-blame)
         ("C-c m m" . magit-list-repositories))
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-diff-refine-hunk t)
  (add-hook 'magit-process-find-password-functions
            #'magit-process-password-auth-source)
  (setq magit-repository-directories '(("~/" . 0)
                                       ("~/.config/" . 3)
                                       ("~/Code" . 2)
                                       ("~/.local/src" . 4)
                                       ("~/Documents/Knowledge" . 1))))
#+END_SRC

#+RESULTS:
| magit-process-password-auth-source |

#+BEGIN_QUOTE
    The following code makes magit-status run alone in the frame, and then restores the old window configuration when you quit out of magit.

    No more juggling windows after commiting. It’s magit bliss.
#+END_QUOTE

From: [[http://whattheemacsd.com/setup-magit.el-01.html][Magnar Sveen]]

#+BEGIN_SRC emacs-lisp :tangle yes
;; full screen magit-status
(defadvice magit-status (around magit-fullscreen activate)
  "Make Magit full screen and restore windows when done."
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restore the previous window configuration and kill the magit buffer."
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

#+RESULTS:
: magit-quit-session

Magit extension for GitHub/GitLab

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package forge
  :after magit)
#+END_SRC

#+RESULTS:

** Yasnippet


Enable Yasnippets.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :defer 15
  :config
  (setq yas-indent-line 'fixed)
  (yas-global-mode))
#+END_SRC

#+RESULTS:
: t

We do however still need some snippets.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package common-lisp-snippets
  :commands lisp-mode
  :after (yasnippet common-lisp))
(use-package yasnippet-snippets
  :after yasnippet)
#+END_SRC

#+RESULTS:

** Ripgrep
Search through files really fast
#+begin_src emacs-lisp :tangle yes
(use-package ripgrep)
#+end_src
** Lisp
*** SLIME
Install the [[https://melpa.org/#/slime][Superior Lisp Interaction Mode for Emacs]].

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package slime
  :config (setq inferior-lisp-program "sbcl"))
#+END_SRC

#+RESULTS:
: t

Set up company for SLIME

#+begin_src emacs-lisp :tangle yes
(use-package slime-company
  :after (slime company)
  :config (slime-setup '(slime-company)))
#+end_src

#+RESULTS:

*** Prelude
Following lisp config mostly taken from [[https://github.com/bbatsov][bbatsov's]] [[https://github.com/bbatsov/prelude][Prelude]].

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters)

(define-key read-expression-map (kbd "TAB") 'completion-at-point)

(defun prelude-lisp-coding-defaults ()
  (smartparens-strict-mode +1)
  (rainbow-delimiters-mode +1))

(setq prelude-lisp-coding-hook 'prelude-lisp-coding-defaults)

;; interactive modes don't need whitespace checks
(defun prelude-interactive-lisp-coding-defaults ()
  (smartparens-strict-mode +1)
  (rainbow-delimiters-mode +1)
  (whitespace-mode -1))

(setq prelude-interactive-lisp-coding-hook
      'prelude-interactive-lisp-coding-defaults)

(add-hook 'lisp-mode-hook (lambda ()
                                  (run-hooks 'prelude-lisp-coding-hook)))
#+end_src

#+RESULTS:
| (lambda nil (run-hooks 'prelude-lisp-coding-hook)) | slime-lisp-mode-hook |

** Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package macrostep
    :bind (("H-`" . macrostep-expand)
           ("H-C-`" . macrostep-collapse)))
#+END_SRC

#+RESULTS:
: macrostep-collapse

*** Prelude
Following emacs-lisp config mostly taken from [[https://github.com/bbatsov][bbatsov's]] [[https://github.com/bbatsov/prelude][Prelude]].

#+begin_src emacs-lisp :tangle yes

  (setq use-package-ensure-function 'use-package-ensure-elpa)
  (use-package rainbow-mode)
  (setq use-package-ensure-function 'quelpa)
  (use-package crux)
  ;(use-package elisp-slime-nav )

  (defun prelude-recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (add-hook 'after-save-hook
              (lambda ()
                (when
                       (file-exists-p (byte-compile-dest-file buffer-file-name))
                  (emacs-lisp-byte-compile)))
              nil
              t))

  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
  (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)

  (defun prelude-conditional-emacs-lisp-checker ()
    "Don't check doc style in Emacs Lisp test files."
    (let ((file-name (buffer-file-name)))
      (when (and file-name (string-match-p ".*-tests?\\.el\\'" file-name))
        (setq-local flycheck-checkers '(emacs-lisp)))))


  (defun prelude-emacs-lisp-mode-defaults ()
    "Sensible defaults for `emacs-lisp-mode'."
    (run-hooks 'prelude-lisp-coding-hook)
    (eldoc-mode +1)
    (prelude-recompile-elc-on-save)
    (rainbow-mode +1)
    (setq mode-name "EL")
    (prelude-conditional-emacs-lisp-checker))

  (setq prelude-emacs-lisp-mode-hook 'prelude-emacs-lisp-mode-defaults)

  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (run-hooks 'prelude-emacs-lisp-mode-hook)))

  ;(with-eval-after-load "elisp-slime-nav"
   ; (diminish 'elisp-slime-nav-mode))
  (with-eval-after-load "rainbow-mode"
    (diminish 'rainbow-mode))
  (with-eval-after-load "eldoc"
    (diminish 'eldoc-mode))

  ;(add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-move 1)))

  (defun conditionally-enable-smartparens-mode ()
    "Enable `smartparens-mode' in the minibuffer, during `eval-expression'."
    (if (eq this-command 'eval-expression)
        (smartparens-mode 1)))

  (add-hook 'minibuffer-setup-hook 'conditionally-enable-smartparens-mode)

#+end_src

#+RESULTS:
| conditionally-enable-smartparens-mode | rfn-eshadow-setup-minibuffer | minibuffer-error-initialize | minibuffer-history-isearch-setup | minibuffer-history-initialize |

** Projectile
Project management and navigation.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :diminish projectile-mode
  :demand
  :bind (("C-c p p" . projectile-switch-project)
         ("C-c p s s" . projectile-ag)
         ("C-c p s r" . projectile-ripgrep))
  :config (define-key projectile-mode-map
  (kbd "C-c p") 'projectile-command-map)
    (projectile-mode 1)
    (setq projectile-enable-caching t)
    (setq projectile-switch-project-action 'projectile-dired))
#+END_SRC

#+RESULTS:
: projectile-ripgrep

** Python
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package python-mode
    :defer t)
#+END_SRC

#+RESULTS:

** Company
Auto completion

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :bind (("C-n" . company-select-next)
         ("C-p" . company-select-previous))
  :config
  (setq company-tooltip-limit 20)
  (setq company-idle-delay .15)
  (setq company-echo-delay 0)
  (setq company-begin-commands '(self-insert-command))
  (global-company-mode))
#+END_SRC

#+RESULTS:
: t

** Stumpwm

#+begin_src emacs-lisp :tangle yes
(use-package stumpwm-mode)
#+end_src

#+RESULTS:

Add a quick way for connecting to the Swank server started by StumpWM.

#+begin_src emacs-lisp :tangle yes
(defvar stumpwm-swank-host "localhost" "Swank host as set in your StumpWM config")
(defvar stumpwm-swank-port 4004 "Swank port as set in your StumpWM config")
(defun stumpwm-connect ()
  (interactive)
  (slime-connect stumpwm-swank-host stumpwm-swank-port))
#+end_src

#+RESULTS:
: stumpwm-connect

** Nov

Install [[https://melpa.org/#/nov][nov]] so I can read epub files in Emacs.

#+begin_src emacs-lisp :tangle yes
(setq use-package-ensure-function 'use-package-ensure-elpa)
(use-package nov
  :commands nov-mode)
(setq use-package-ensure-function 'quelpa)
#+end_src

#+RESULTS:
: quelpa

Enable nov-mode for epub files.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+end_src

Properly justify text.
This requires [[https://github.com/Fuco1/justify-kp][justify-kp]] which is unfortunately not in MELPA,
since it hasn't been updated since <2019-11-19>.
It is still up on github though so we can do a quick clone.

#+BEGIN_SRC bash
cd "$HOME/.emacs.d/elpa/"
git clone "https://github.com/Fuco1/justify-kp"
#+END_SRC

It should also be available as a git submodule of my .emacs.d repo

#+begin_src emacs-lisp :tangle yes
(use-package justify-kp
:quelpa (justify-kp :fetcher github :repo "Fuco1/justify-kp")
:after nov
:config
(setq nov-text-width t)
(defun nov-justify-hook ()
  "Justify nov buffer."
  (if (get-buffer-window)
      (
       let ((max-width (pj-line-width))
            buffer-read-only)
       (save-excursion
         (goto-char (point-min))
         (while (not (eobp))
           (when (not (looking-at "^[[:space:]]*$"))
             (goto-char (line-end-position))
             (when (> (shr-pixel-column) max-width)
               (goto-char (line-beginning-position))
               (pj-justify)))
           (forward-line 1)))
       (toggle-word-wrap 1)
       )
    (add-hook 'window-configuration-change-hook
              'my-nov-window-configuration-change-hook
              nil t))

(defun my-nov-window-configuration-change-hook ()
  "Justify on nov window change."
  (nov-justify-hook)
  (remove-hook 'window-configuration-change-hook
               'my-nov-window-configuration-change-hook
               t))
(add-hook 'nov-post-html-render-hook 'nov-justify-hook)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun prepare-nov-mode-hook ()
  "Disable `whitespace-mode' in `nov-mode' since it makes reading hard."
  (whitespace-mode 1)
  (whitespace-mode 0))

(add-hook 'nov-post-html-render-hook 'prepare-nov-mode-hook)
#+end_src

** CMake
#+begin_src emacs-lisp :tangle yes
(use-package cmake-mode
  :commands cmake-mode)

(defun maybe-cmake-project-mode ()
  (if (or (file-exists-p "CMakeLists.txt")
          (file-exists-p (expand-file-name "CMakeLists.txt" (car (project-roots (project-current))))))
      (cmake-project-mode)))

(use-package cmake-project
  :after cmake-mode
  :config
  (add-hook 'c-mode-hook 'maybe-cmake-project-mode)
  (add-hook 'c++-mode-hook 'maybe-cmake-project-mode))
#+end_src
** Tramp
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package tramp
    :config (setq tramp-default-method "ssh"))
#+END_SRC

** JSON
#+begin_src emacs-lisp :tangle yes
(use-package json-mode)
#+end_src

** Centered Window Mode
#+begin_src emacs-lisp :tangle yes
;(use-package centered-window-mode)

(defvar cwm-whitelist '(nov-mode)
  "Whitelist `centered-window-mode' in the given major modes")

(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
   (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))

;(defun centered-window-mode-on-buffer-switch-hook ())
;  (if (member (buffer-mode) cwm-whitelist)
;      (centered-window-mode 1)
;    (centered-window-mode 0)))



;(setq cwm-centered-window-width 80)
;(setq cwm-incremental-padding t)
;(setq cwm-incremental-padding-% 20)

;(add-hook 'buffer-list-update-hook 'centered-window-mode-on-buffer-switch-hook)
#+end_src
** Web server
#+begin_src emacs-lisp :tangle yes
(use-package web-server)
#+end_src
** God Mode

#+begin_src emacs-lisp :tangle yes
(use-package god-mode)

;(god-mode)
(global-set-key (kbd "<escape>") #'god-local-mode)

(defun my-god-mode-update-cursor ()
  (setq cursor-type (if (or overwrite-mode (or god-local-mode buffer-read-only))
                        'box
                      'bar)))

(add-hook 'god-mode-enabled-hook #'my-god-mode-update-cursor)
(add-hook 'overwrite-mode-hook #'my-god-mode-update-cursor)
(add-hook 'buffer-list-update-hook #'my-god-mode-update-cursor)
(add-hook 'god-mode-disabled-hook #'my-god-mode-update-cursor)

(define-key god-local-mode-map (kbd ".") #'repeat)
(global-set-key (kbd "C-x C-1") #'delete-other-windows)
(global-set-key (kbd "C-x C-2") #'split-window-below)
(global-set-key (kbd "C-x C-3") #'split-window-right)
(global-set-key (kbd "C-x C-0") #'delete-window)
#+end_src

Change color of mode line when in god-mode

#+begin_src emacs-lisp :tangle yes

(use-package ewal-doom-themes)

(defun my-god-mode-update-modeline ()
  "Update the mode line colors when in god-mode"
  (let ((mode-line-fg-default (ewal-doom-themes-get-color 'background -3))
        (mode-line-fg-god (ewal-doom-themes-get-color 'background -3))
        (red (ewal-doom-themes-get-color 'red  5))
        (blue (ewal-doom-themes-get-color 'blue 0)))
    (cond
     (god-local-mode
      (progn
        (set-face-background
         'mode-line
         (car (doom-lighten mode-line-fg-god 0.15)))
        (set-face-background
         'mode-line-inactive
          (car (doom-darken mode-line-fg-default 0.1)))
        (set-face-background
         'cursor
         (car red))))
     (t (progn
          (set-face-background
           'mode-line
           (car (doom-darken mode-line-fg-default 0.15)))
          (set-face-background
           'mode-line-inactive
           (car (doom-darken mode-line-fg-default 0.1)))
          (set-face-background
           'cursor
           (car blue)))))))

(add-hook 'god-mode-enabled-hook #'my-god-mode-update-modeline)
(add-hook 'buffer-list-update-hook #'my-god-mode-update-modeline)
(add-hook 'god-mode-disabled-hook #'my-god-mode-update-modeline)
#+end_src

* Keybindings
** Org-mode
#+begin_src emacs-lisp :tangle yes
(defun org-agenda-sync ()
"Sync notes between emacs and android"
(interactive)
(async-shell-command "agendaSync"))

(define-key org-mode-map (kbd "H-s") 'org-agenda-sync)
#+end_src
** C
#+begin_src emacs-lisp :tangle yes
  (define-key c-mode-map (kbd "C-c r") 'srefactor-refactor-at-point)
#+end_src
** C++
#+begin_src emacs-lisp :tangle yes
  (define-key c++-mode-map (kbd "C-c r") 'srefactor-refactor-at-point)
#+end_src
** Global
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-d") 'crux-duplicate-current-line-or-region)

(global-set-key (kbd "<delete>") 'delete-char)

(global-set-key (kbd "C-x x") 'replace-regexp)
(global-set-key (kbd "C-x c C-c") 'replace-string)

(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

(global-set-key (kbd "C-x O") (lambda ()
                                (interactive)
                                (other-window -1))) ;; back one

(bind-key "C-k" 'crux-kill-whole-line)

(bind-key "C-M-x" 'kmacro-call-macro)

(bind-key "C-c c" 'org-capture)
(bind-key "C-c a" 'org-agenda)

(bind-key "C-." 'hippie-expand)

#+end_src



#+RESULTS:
: hippie-expand


#+begin_src emacs-lisp :tangle yes
(defcustom after-save-interactively-hook nil
  "Normal hook that is run after a buffer is saved interactively to its file.
See `run-hooks'."
  :group 'files
  :type 'hook)

(defun save-buffer-and-call-interactive-hooks (&optional arg)
  "Save the buffer and call hooks if called interactively.
ARG is passed to 'save-buffer'"
  (interactive "p")
  (save-buffer arg)
  (when (called-interactively-p 'all)  ;; run post-hooks only if called interactively
    (run-hooks 'after-save-interactively-hook)))

(global-set-key (kbd "C-x s") 'save-buffer-and-call-interactive-hooks)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region

  :bind ("C-=" . er/expand-region))
#+END_SRC
*** Roam

#+begin_src emacs-lisp :tangle yes

(defvar global-roam-map (make-keymap "Org-Roam")
"Global keymap for org-roam commands")

(bind-key "C-j" global-roam-map)
(bind-key "C-j" global-roam-map org-mode-map)

(bind-key "C-j J" #'org-roam-capture)
(bind-key "C-j j" #'org-roam-find-file)

(bind-key "C-j C-j" #'org-roam-insert)

(defun org-roam-grep-content (regexp)
  "Use REGEXP to search `org-roam-directory' contents."
  (interactive "sSearch: ")
  (ripgrep-regexp regexp org-roam-directory '("-g \"*.org\"")))

(bind-key "C-j g" #'org-roam-grep-content)

(bind-key "C-j b" #'org-roam)

#+end_src

* User Interface

I do enjoy myself a good looking user interface.
In fact customization of graphical elements is one of the reason
I use Emacs.

** Unicode
Enable unicode fonts using the suprisingly named package [[https://melpa.org/#/unicode-fonts][unicode-fonts]]

This does require that some Unicode fonts exists.

#+BEGIN_SRC bash
yay -S ttf-symbola quivira ttf-dejavu noto-fonts noto-fonts-emoji noto-fonts-extra
#+END_SRC

Setting up this package for the first time may take upwards of 5 minutes
the first time you start Emacs. There is a lot of unicode characters.

#+begin_src emacs-lisp :tangle yes
(use-package unicode-fonts
  :config (unicode-fonts-setup))
#+end_src

** Themes
*** Pywal
Currently I use [[https://github.com/dylanaraps/pywal][pywal]] to dynamically
generate a colour scheme on the fly from my current background, which I
change automatically every 5 minutes

Ideally I would apply that colour scheme to my Emacs theme as well.
*** ewal

#+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "wal")
        (use-package ewal
          :config (setq ewal-use-built-in-always-p nil
                      ewal-use-built-in-on-failure-p t
                  ewal-json-file "~/.cache/wal/colors.json"
                  ewal-built-in-palette "sexy-material")))
#+END_SRC

#+RESULTS:


Thankfully [[https://melpa.org/#/ewal][ewal]] exist so I can just
use that.

Now we need a theme that knows how to apply the scheme colours.
[[https://melpa.org/#/ewal-doom-themes][ewal-doom-themes]] looks pretty nice.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ewal-doom-themes
  :config
  (if (executable-find "wal")
      (progn
        (load-theme 'ewal-doom-one t)
        (enable-theme 'ewal-doom-one))
    (progn (load-theme 'doom-molokai t)
           (enable-theme 'doom-molokai))))
#+END_SRC

#+RESULTS:

We do need to configure some things so that the ewal theme is reapplied
every time the background changes, since apparently that is not a common
circumstance.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (executable-find "wal")
  (defun refresh-theme ()
    "Reload the theme."
    (load-theme 'ewal-doom-one t)
    (run-hooks 'buffer-list-update-hook))

  (defun theme-callback (event)
    "Callback for refreshing the theme.  Parameter EVENT is ignored."
    (refresh-theme))

  (use-package filenotify)
  (file-notify-add-watch
   "~/.cache/wal/colors.json" '(change) 'theme-callback)

  (enable-theme 'ewal-doom-one))
#+END_SRC



# It may be needed to remove the background color
# from emacs when run from terminal
# (defun remove-bg-color ()  "Don't show bg color in terminal."
#       (unless (display-graphic-p (selected-frame))
#         (set-face-background 'default "unspecified-bg" (selected-frame)) ))
# (add-hook 'window-setup-hook 'remove-bg-color)

*** Safe themes
Mark all themes as safe for simplicity.
#+begin_src emacs-lisp :tangle yes
(setq custom-safe-themes t)
#+end_src

** Org Appearance

Org mode is something I use quite often (case in point)
so I would prefer it would look fairly decent.

#+begin_src emacs-lisp :tangle yes
        (setq org-fontify-done-headline t
              org-fontify-whole-heading-line t
              org-src-fontify-natively t
              org-src-window-setup 'current-window
              org-src-strip-leading-and-trailing-blank-lines t
              org-src-preserve-indentation t)

#+end_src

I set headlines to fontify the whole line
as well as change the face when marked DONE.
Also fontify code blocks.

*Obviously* we /want/ to =display= emphasis markers as what they _do_
rather than some +random characters+.

#+begin_src emacs-lisp :tangle yes
  (setq org-hide-emphasis-markers t)
#+end_src

And we want some fancy UTF8 characters for entries
#+begin_src emacs-lisp :tangle yes
  (setq org-pretty-entities t)
#+end_src

Since I write in \LaTeX a lot I would prefer if \LaTeX things
were being highlighted.

#+begin_src emacs-lisp :tangle yes
  (setq org-highlight-latex-and-related (quote (native script entities)))
#+end_src

Finally replace the default ... when a heading is collapsed
with a fancy unicode arrow ↘

#+begin_src emacs-lisp :tangle yes
(setq org-ellipsis "↘")
#+end_src

** Icons

Enable icons in various buffers with [[https://melpa.org/#/all-the-icons][all-the-icons]].

#+begin_src emacs-lisp :tangle yes
  (use-package all-the-icons)

  (use-package all-the-icons-ibuffer
    :after (all-the-icons ibuffer)
    :commands ibuffer
    :config (all-the-icons-ibuffer-mode 1))

  (use-package all-the-icons-gnus
    :after (all-the-icons gnus)
    :config (all-the-icons-gnus-setup))

  (use-package all-the-icons-dired
    :after (all-the-icons ibuffer)
    :config (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (use-package all-the-icons-ivy
    :after (all-the-icons ivy)
    :config (all-the-icons-ivy-setup))
#+end_src

Display tags everywere as fancy svg icons.

#+begin_src emacs-lisp :tangle no
(use-package svg-tag-mode
  :quelpa (svg-tag-mode :repo "rougier/svg-tag-mode"
                        :fetcher github
                        :files ("svg-tag-mode.el")))
(define-globalized-minor-mode global-svg-tag-mode svg-tag-mode
    (lambda () (svg-tag-mode 1)))

(defun svg-tag-round (text)
      (svg-tag-make (substring text 1 -1) nil 2 2 12))
(setq svg-tag-tags '(("@[a-zA-Z0-9]+?@" . svg-tag-round)))
#+end_src

** Font Ligatures

Font ligatures sure are nice.

I happen to know that the [[https://github.com/tonsky/FiraCode][Fira Code]] ones are doubly so.

First we need to set the default font to Fire Code.

That requires that it is installed on the system of course.

Thankfully I happen to know that a nice Fira Code package exists in the [[https://aur.archlinux.org/packages/otf-fira-code-symbol/][AUR]].

#+BEGIN_SRC bash
  yay -S "otf-fira-code-symbol" "ttf-fira-code"
#+END_SRC

We also need to set the Fira Code as the actual font for emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'default-frame-alist
	       (cond
		((string-equal system-type "gnu/linux") '(font . "Fira Code-12"))))
#+END_SRC

#+begin_src emacs-lisp :tangle yes
  (use-package fira-code-mode
      :config (define-globalized-minor-mode global-fira-code-mode fira-code-mode
    (lambda () (fira-code-mode 1))))
#+end_src

Make a global minor mode for Fira code font ligatures.

** Modeline

Enable [[https://melpa.org/#/doom-modeline][doom-modeline]].

#+begin_src emacs-lisp :tangle yes
  (use-package doom-modeline
    :config (doom-modeline-mode 1))
#+end_src

Enable icons in the modeline

#+begin_src emacs-lisp :tangle yes
  (setq doom-modeline-icon t)
#+end_src

Don't show time in the Emacs modeline.
I have the Stumpwm modeline for that.

#+begin_src emacs-lisp :tangle yes
  (display-time-mode 0)
#+end_src

#+RESULTS:

Diplay the column number in the modeline

#+BEGIN_SRC emacs-lisp :tangle yes
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC


The following function for occur-dwim is taken from
[[https://github.com/abo-abo][Oleh Krehel]] from his
[[http://oremacs.com/2015/01/26/occur-dwim/][blog post at (or emacs]]. It takes
the current region or the symbol at point
as the default value for occur.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun occur-dwim ()
  "Call `occur' with a sane default."
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (thing-at-point 'symbol))
        regexp-history)
  (call-interactively 'occur))

(bind-key "M-s o" 'occur-dwim)
#+END_SRC

Make page breaks pretty instead of ~^L~.
See also this [[http://ericjmritz.name/2015/08/29/using-page-breaks-in-gnu-emacs/][article]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package page-break-lines)
#+END_SRC

** Ibuffer
Use Ibuffer by default.
#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'list-buffers 'ibuffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'dired-mode-hook 'auto-revert-mode)

  ;; Also auto refresh dired, but be quiet about it
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
#+END_SRC

Save recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :config
    (recentf-mode t)
    (setq recentf-max-saved-items 500))
#+END_SRC

** Splash
Lately I've felt like opening =*scratch*= when I start Emacs
is sort of a waste.

I use =*scratch*= sparingly so having some kind of hub thingy instead
could be more useful.


So I want to implement one.

I don't have any idea what might be useful there so let's just wing it.


Having some recently visited files might be nice.

So firstly let's write a function to get the last N visited files.
I use =recentf= to keep track of that usually so we can probably get the
information from there.

#+begin_src emacs-lisp :tangle yes
(defun last-visited (&optional count)
  "Find last COUNT visited items."
  (cl-loop for n
         from 0
         below (or count 10)
         collect (nth n recentf-list)))
#+end_src

There has to be an emacs lisp function to get the first N elements of a list
that I can't find. This will do until I figure it out.


Maybe being able to see my last active repos could be fine.

I don't think =magit= stores your last active repos so we can just approximate
with the function above

#+begin_src emacs-lisp :tangle yes

(defun last-repos-dir (&optional count)
  "Find last active repositories, checking the last COUNT files visited."
  (remove-duplicates
   (flatten-list
    (remove-if #'null
               (mapcar #'magit-toplevel
                       (last-visited (or count 30)))))
   :test #'string=))

#+end_src

This however returns the /local (or remote really)/ path where the repo is
cloned.



#+begin_src emacs-lisp :tangle yes

(defmacro magit-with-repository (repo &rest body)
  "Evaluate BODY as if REPO was the currently active directory."
  `(let ((default-directory ,repo))
     ,@body
     ))

(defun repo-origin (repo)
  "Return the origin remote of REPO."
  (magit-with-repository repo
                         (magit-get "remote.origin.url")))

(defun last-repos (&optional count)
  (mapcar #'repo-origin (last-repos-dir count)))
#+end_src

Let's see if it gets it right.

#+begin_src emacs-lisp :tangle no :results none
(mapcar #'(lambda (repo) (concat repo "\n"))
        (last-repos 1))
#+end_src

#+RESULTS:
| https://github.com/Kalelzar/emacs.git |

\*looks up to address bar\*

Seems right to me.


What else... What else...

Latest commits?

Sure let's go with that.

#+begin_src emacs-lisp :tangle no
(defun latest-commits ()

)
#+end_src

** Misc

Disable fringes.

#+begin_src emacs-lisp :tangle yes
  (fringe-mode 0)
#+end_src

Disable the blinking cursor.

#+BEGIN_SRC emacs-lisp :tangle yes
(blink-cursor-mode -1)
#+END_SRC

Show matching parenthesis.

#+begin_src emacs-lisp :tangle yes
  (show-paren-mode t)
#+end_src

Wrap lines properly

#+BEGIN_SRC emacs-lisp :tangle yes
(global-visual-line-mode)
(diminish 'visual-line-mode)
#+END_SRC

Smooth scrolling

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smooth-scrolling)
(smooth-scrolling-mode)
#+END_SRC

Use bar cursor

#+begin_src emacs-lisp :tangle yes
(use-package bar-cursor)
(bar-cursor-mode 1)
(diminish 'bar-cursor-mode)
#+end_src
* Footer
#+begin_src emacs-lisp :tangle yes
(message "Loaded config")
(provide 'config)
;;; config.el ends here
#+end_src
